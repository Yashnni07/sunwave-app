// Fetch saved posts
app.get("/api/saved-posts", authenticateToken, async (req, res) => {
    try {
      const userEmail = req.user.email; // Retrieve user email from token
  
      // Call chaincode to fetch the user data
      const response = await contract.evaluateTransaction('fetchUserByEmail', userEmail);
  
      const user = JSON.parse(response.toString());
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
  
      res.status(200).json({ savedPosts: user.savedPosts || [] });
    } catch (error) {
      console.error("Error fetching saved posts:", error);
      res.status(500).json({ error: "Internal server error" });
    }
});

// Remove saved post
app.post('/api/remove-saved-post', authenticateToken, async (req, res) => {
    try {
      const userEmail = req.user.email; // Retrieve user email from token
      const { postId } = req.body; // Get the postId from the request body
  
      // Call chaincode to fetch the user data
      const response = await contract.evaluateTransaction('fetchUserByEmail', userEmail);
      const user = JSON.parse(response.toString());
  
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
  
      // Ensure the post exists in savedPosts
      const postIndex = user.savedPosts.findIndex((p) => p._id === postId);
      if (postIndex === -1) {
        return res.status(404).json({ error: 'Post not found in saved posts' });
      }
  
      // Remove the post from savedPosts
      user.savedPosts.splice(postIndex, 1);
  
      // Update the user data in the blockchain
      await contract.submitTransaction('updateUser', userEmail, JSON.stringify(user));
  
      res.status(200).json({ message: 'Post removed successfully!' });
    } catch (error) {
      console.error('Error removing saved post:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
});

// Delete post and remove references from saved posts
app.delete('/api/delete-post/:postId', authenticateToken, async (req, res) => {
    try {
      const { postId } = req.params;
  
      // Call chaincode to delete the post
      const response = await contract.submitTransaction('deletePost', postId);
      const result = JSON.parse(response.toString());
  
      if (result.error) {
        return res.status(400).json({ error: result.error });
      }
  
      res.status(200).json({ message: result.message }); // Success message from chaincode
    } catch (error) {
      console.error('Error deleting post:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
});

// Flag Post
app.post("/api/flag-post", authenticateToken, async (req, res) => {
    const { postId } = req.body;
    const userEmail = req.user.email;
  
    try {
      // Call chaincode to fetch the post data
      const response = await contract.evaluateTransaction('fetchPost', postId);
      const post = JSON.parse(response.toString());
  
      // Check if the post is already flagged by the user
      if (post.flaggedBy && post.flaggedBy.includes(userEmail)) {
        return res.status(400).json({ message: "Post already flagged by this user" });
      }
  
      // Add the user's email to the flaggedBy array and update flagCount
      const updatedFlaggedBy = [...(post.flaggedBy || []), userEmail];
      post.flaggedBy = updatedFlaggedBy;
      post.flagVerified = true; // Set flagVerified to true
      post.flagCount = updatedFlaggedBy.length; // Update flag count
  
      // Call chaincode to update the post
      await contract.submitTransaction('updatePost', postId, JSON.stringify(post));
  
      res.status(200).json({ message: "Post flagged successfully" });
    } catch (error) {
      console.error("Error flagging post:", error);
      res.status(500).json({ message: "Failed to flag post" });
    }
});

// GET Flagged Posts
app.get("/api/flagged-posts", authenticateToken, async (req, res) => {
    try {
      // Call chaincode to fetch all flagged posts
      const response = await contract.evaluateTransaction('fetchFlaggedPosts');
      const flaggedPosts = JSON.parse(response.toString());
  
      // Format the posts before sending to the client
      const formattedPosts = flaggedPosts.map((post) => ({
        _id: post._id,
        title: post.title,
        content: post.content,
        image: post.image,
        createdAt: post.createdAt,
        flaggedBy: post.flaggedBy || [],
        flagCount: post.flagCount || 0,
        username: post.username,
        studentId: post.studentId,
      }));
  
      res.status(200).json(formattedPosts);
    } catch (error) {
      console.error("Error fetching flagged posts:", error);
      res.status(500).json({ message: "Failed to fetch flagged posts" });
    }
});

// Delete Flagged Posts
app.delete("/api/flagged-posts/:postId", authenticateToken, async (req, res) => {
    const { postId } = req.params;
  
    try {
        // Call chaincode to delete the flagged post and remove it from users' saved posts
        await contract.submitTransaction('deleteFlaggedPost', postId);
  
        res.status(200).json({ message: "Post deleted successfully" });
    } catch (error) {
        console.error("Error deleting flagged post:", error);
        res.status(500).json({ message: "Failed to delete flagged post" });
    }
});

// Moderator upload event
// Moderator upload event
app.post("/api/moderator/upload-event", authenticateToken, async (req, res) => {
    try {
      const userEmail = req.user.email; // Retrieve user email from the token
      const {
        title,
        description,
        date,
        time,
        image,
        location,
        eventType,
        voteOptions,
      } = req.body;
  
      // Fetch the user from the blockchain (instead of database)
      const response = await contract.evaluateTransaction('fetchUserByEmail', userEmail);
      const user = JSON.parse(response.toString());
  
      if (!user) {
        return res.status(404).json({ error: "Moderator not found" });
      }
  
      if (user.role !== "Moderator") {
        return res.status(403).json({ error: "Unauthorized: Not a Moderator" });
      }
  
      // Validate event type and vote options for voting events
      if (eventType === "voting" && (!voteOptions || voteOptions.length < 2)) {
        return res.status(400).json({ error: "Voting events require at least 2 vote options" });
      }
  
      // Generate timestamp for event creation (handled by the server)
      const eventDateCreated = new Date().toISOString();
  
      const eventDetails = {
        title,
        description,
        date,
        time,
        image,
        location,
        eventType: eventType || "normal", // Default to normal
        voteOptions:
          eventType === "voting"
            ? voteOptions.map((option) => ({ ...option, votes: 0 }))
            : undefined,
      };
  
      // Submit the event to the blockchain
      const eventResponse = await contract.submitTransaction('createEvent', JSON.stringify(eventDetails), eventDateCreated);
      const eventId = eventResponse.toString(); // Event ID returned by the chaincode
  
      // Update the moderator's "myEvents" on the blockchain
      const updatedMyEvents = [...(user.myEvents || []), eventId];
      await contract.submitTransaction('updateUserEvents', userEmail, JSON.stringify(updatedMyEvents));
  
      res.status(201).json({
        message: "Event uploaded successfully",
        eventId: eventId,
      });
    } catch (error) {
      console.error("Error uploading event:", error);
      res.status(500).json({ error: "Internal server error" });
    }
});

// Endpoint to fetch user-created events
// Get events created by the current user
app.get("/api/user-created-events", authenticateToken, async (req, res) => {
    try {
      const userEmail = req.user.email; // Extract the user email from the token
  
      // Fetch normal events created by the user
      const normalEventsResult = await contract.evaluateTransaction('fetchNormalEventsByUser', userEmail);
      const normalEvents = JSON.parse(normalEventsResult.toString()).events || [];
  
      // Fetch voting events created by the user
      const votingEventsResult = await contract.evaluateTransaction('fetchVotingEventsByUser', userEmail);
      const votingEvents = JSON.parse(votingEventsResult.toString()).events || [];
  
      // Respond with both normal and voting events
      res.status(200).json({
        normalEvents,
        votingEvents,
      });
    } catch (error) {
      console.error("Error fetching user-created events:", error);
      res.status(500).json({ error: "Internal server error" });
    }
});

// Endpoint to fetch joined users for a normal event
app.get("/api/event-joined-users/:eventId", authenticateToken, async (req, res) => {
    try {
      const eventId = req.params.eventId;
  
      // Fetch event details from the blockchain
      const eventResult = await contract.evaluateTransaction('fetchEventById', eventId);
      const event = JSON.parse(eventResult.toString());
  
      if (!event) {
        return res.status(404).json({ error: "Event not found" });
      }
  
      // Fetch user details for all joined users
      const joinedUsers = await Promise.all(
        (event.joinedUsers || []).map(async (userId) => {
          const userResult = await contract.evaluateTransaction('fetchUserByEmail', userId);
          const user = JSON.parse(userResult.toString());
  
          return {
            username: user.username,
            userId: user.email,  // Assuming user ID is email
            studentId: user.studentId,
          };
        })
      );
  
      res.status(200).json(joinedUsers);
    } catch (error) {
      console.error("Error fetching joined users:", error);
      res.status(500).json({ error: "Error fetching joined users" });
    }
});

// Endpoint to fetch voting results for a voting event
app.get("/api/voting-results/:eventId", authenticateToken, async (req, res) => {
    try {
      const eventId = req.params.eventId;
  
      // Fetch the voting event from the blockchain
      const votingEventResult = await contract.evaluateTransaction('fetchEventById', eventId);
      const votingEvent = JSON.parse(votingEventResult.toString());
  
      if (!votingEvent) {
        return res.status(404).json({ error: "Voting event not found" });
      }
  
      // Fetch the voting results for each option
      const votingResults = await Promise.all(
        votingEvent.voteOptions.map(async (option) => {
          // For each option, fetch the voters
          const voters = await Promise.all(
            (option.voters || []).map(async (voterId) => {
              // Fetch user details by userId (email or unique identifier)
              const userResult = await contract.evaluateTransaction('fetchUserByEmail', voterId);
              const user = JSON.parse(userResult.toString());
              
              return {
                username: user.username,
                userId: user.email,  // Assuming userId is email
                studentId: user.studentId,
              };
            })
          );
  
          return {
            option: option.name,
            votes: option.votes,
            voters,
          };
        })
      );
  
      res.status(200).json(votingResults);
    } catch (error) {
      console.error("Error fetching voting results:", error);
      res.status(500).json({ error: "Error fetching voting results" });
    }
});

// Endpoint to get an event total joined user count
app.get("/api/users/joined-events-count", authenticateToken, async (req, res) => {
    try {
      const userEmail = req.user.email; // Extract user email from the token
  
      // Fetch the user from the blockchain
      const userResult = await contract.evaluateTransaction('fetchUserByEmail', userEmail);
      const user = JSON.parse(userResult.toString());
  
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
  
      // Count the number of joined events
      const joinedEventsCount = (user.joinedEvents || []).length;
  
      res.status(200).json({ joinedEventsCount });
    } catch (error) {
      console.error("Error fetching joined events count:", error);
      res.status(500).json({ error: "Internal server error" });
    }
});

// Endpoint to get option vote count for a voting event
app.get("/api/voting-event/:eventId", authenticateToken, async (req, res) => {
    try {
      const { eventId } = req.params;
  
      // Fetch the voting event by ID from the blockchain
      const eventResult = await contract.evaluateTransaction('fetchVotingEventById', eventId);
      const event = JSON.parse(eventResult.toString());
  
      if (!event || event.eventType !== "voting") {
        return res.status(404).json({ error: "Voting event not found" });
      }
  
      // Extract vote options and their counts
      const voteOptions = event.voteOptions.map((option) => ({
        name: option.name,
        votes: option.votes,
      }));
  
      res.status(200).json({ voteOptions });
    } catch (error) {
      console.error("Error fetching voting event:", error);
      res.status(500).json({ error: "Internal server error" });
    }
});
  
  
  
  
  
  
  
  

  

  
  

  
